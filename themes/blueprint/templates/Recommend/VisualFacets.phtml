<?
    $this->headScript()->appendFile("d3.js");

    $visualFacetSet = $this->recommend->getPivotFacetSet();

    $flarechildren = array();

    foreach ($visualFacetSet->children as $toplevelfacet) {
          $toplevelinfo = array();
          $toplevelchildren = array();
          $toplevelinfo['name'] = $toplevelfacet['value'];
          $toplevelinfo['field'] = $toplevelfacet['field'];
          $toplevelinfo['size'] = $toplevelfacet['count'];
          foreach($toplevelfacet['pivot'] as $secondlevelfacet) {
               $secondlevelinfo = array();
               $secondlevelinfo['name'] = $secondlevelfacet['value'];
               $secondlevelinfo['size'] = $secondlevelfacet['count'];
               $secondlevelinfo['field'] = $secondlevelfacet['field'];
               $secondlevelinfo['parentlevel'] = $toplevelinfo['name'];
               array_push($toplevelchildren, $secondlevelinfo);
          }
          $toplevelinfo['children'] = $toplevelchildren;
          array_push($flarechildren, $toplevelinfo);
     }

    $visualFacetSet->children = $flarechildren;
?>

<? if (isset($visualFacetSet)): ?>

    <script type="text/javascript">

    <? $pivotdata = json_encode($visualFacetSet);

    echo "var pivotdata = " . $pivotdata . ";"; ?>

    jQuery(document).ready(function(data) {

    if (!d3.select("#visualResults").empty()) {

        $('.limitSelect').css('display', 'none');

        $('.sortSelector').css('display', 'none');

        $('.pagination').css('display', 'none');

        $('.bulkActionButtons').css('display', 'none');

        //  Color scheme developed using the awesome site
        //  http://colorschemedesigner.com
        //  Hue degrees (in order) -- 90, 105, 120, 135, 150
        //  Even numbered degrees are 100% brightness, 50% saturation
        //  Odd numbered degrees are 100% brightness, 25% saturation

        var color = d3.scale.ordinal()
          .range([
            "#A385FF", "#FF7975", "#C2FFE7", "#FFE775",
            "#75FF7E", "#FFD4C2", "#E0C7FF", "#D1FF75",
            "#D17DFF", "#FFB475", "#FFFF75", "#FF75C3",
            "#FFD175", "#C6E6FF", "#FFE5C2", "#FFC2FF",
            "#FFFF75", "#84A9FF", "#F5FFC2", "#FFFAC2",
            "#AAAAAA"])
          .domain(["A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "U", "V", "Z"]);

        var div = d3.select("#visualResults")
          .style("width", "710px")
          .style("height", "575px")
          .style("position", "absolute");

        var treemap = d3.layout.treemap()
          .size([710, 575])
          .sticky(true)
          .mode("squarify")
          .padding(0,0,0,18)
          .value(function(d) { return d.size; });

        // Total count of items matching the search;
        // will be used below to do math to size the boxes properly.

        var totalbooks = pivotdata.total;

        $.each(pivotdata.children, function(facetindex, facetdata) {
            //Saving the original size in a "count" variable
            //that won't be resized.

            facetdata.count = facetdata.size;

            // If a first-level container contains less than 10%
            // of the total results, don't show any child containers
            // within that first-level container. You won't be able
            // to read them and they'll just clutter up the display.

            if (facetdata.size < totalbooks * .1) {
                var onechild = new Object();
                onechild.name = facetdata.name;
                onechild.size = facetdata.size;
                onechild.count = facetdata.count;
                onechild.field = facetdata.field;
                delete pivotdata.children[facetindex].children;
                pivotdata.children[facetindex].children = new Array();
                pivotdata.children[facetindex].children.push(onechild);
            } else {

                // Used to keep count of the total number of child
                // facets under a first-level facet. Used for
                // properly sizing multi-valued data.

                var totalbyfirstpivot = 0;
                $.each(facetdata.children, function(childindex, childdata) {
                    totalbyfirstpivot += childdata.size;
                });

                // Now we roll back through the "facetdata.children"
                // object (which contains all of the child facets in
                // a top-level facet) and combine the smallest X% of
                // squares into a "More topics" box.
                //
                // And then size the child boxes based on facetdata.size,
                // which, as long as our top-level field is not
                // multi-valued, is accurately sized for the number of
                // items in the first-level container.
                //
                // If a single child facet contains less than 5% of the
                // child facet results in a top-level container, roll it
                // into a "More topics" box. Unless the top-level container
                // is between 15% and 30% of the entire results; in that
                // case, only roll up topic facets that are less than 2% of
                // the box. If the top-level container is more than 30% but
                // less than 100% of the entire results, only roll up child
                // facets that are less than 1% of the facet results in that
                // container. If the top-level container is 100% of the
                // entire results, don't roll up any child facets.

                var morefacet = 0;
                var morecount = 0;
                var resizedData = new Array();
                $.each(facetdata.children, function(childindex, childdata) {
                    if (childdata && (childdata.size < totalbyfirstpivot * .05 && facetdata.size < totalbooks * .15 || childdata.size < totalbyfirstpivot * .02 && facetdata.size < totalbooks * .3 || childdata.size < totalbyfirstpivot * .01 && facetdata.size != totalbooks)) {
                    morefacet += childdata.size;
                    morecount++;
                } else if (childdata) {

                    //If it's not going into the "more" facet, save the
                    //count in a new variable, scale the size properly,
                    //and add it to a new array

                    var childobject = childdata;
                    childobject.count = childdata.size;
                    childobject.size = childdata.size/totalbyfirstpivot * facetdata.size;
                    resizedData.push(childobject);
                }
            });

            delete pivotdata.children[facetindex].children;

            // Stop! Using this algorithm, sometimes all of the topics wind
            // up in a "More" facet, which leads to a confusing display. If
            // that happens, just display the top level, with no topic
            // boxes inside the callnumber-first box.

            if (morefacet == totalbyfirstpivot) {
                var onechild = new Object();
                onechild.name = facetdata.name;
                onechild.size = facetdata.size;
                onechild.count = facetdata.count;
                onechild.field = facetdata.field;
                pivotdata.children[facetindex].children = new Array();
                pivotdata.children[facetindex].children.push(onechild);
            } else {

                //If we're keeping the "More" facet, let's size it properly

                pivotdata.children[facetindex].children = resizedData;
                var more = new Object();
                more.name = "<?=$this->transEsc('More Topics')?>";
                more.size = morefacet/totalbyfirstpivot * facetdata.size;
                more.field = "topic_facet";
                more.count = morecount;
                more.parentlevel = facetdata.name;
                pivotdata.children[facetindex].children.push(more);
            }
        }
    });

      var node = div.datum(pivotdata).selectAll(".node")
          .data(treemap.nodes)
              .enter().append("a")
          .attr("href", function(d) {
            if (d.parentlevel && d.name != "<?=$this->transEsc('More Topics')?>") {
                return window.location + "&filter[]=" + d.field + ":\"" + d.name + "\"&filter[]=callnumber-first:\"" + d.parentlevel + "\"&view=list";
                } else if (d.name == "<?=$this->transEsc('More Topics')?>") {
                return window.location + "&filter[]=callnumber-first:\"" + d.parentlevel + "\"";
            } else if (d.name != "theData") {
                return window.location + "&filter[]=" + d.field + ":\"" + d.name + "\"";
            }
        })
          .append("div")
          .attr("class", function(d) { return d.field == "callnumber-first" ? "node toplevel" : "node secondlevel" })
          .attr("id", function(d) { return  d.name.replace(/\s+/g, ''); })
          .call(position)
          .style("background", function(d) { return d.children ? color(d.name.substr(0,1)) : null; })
          .call(settitle)
              .style("z-index", function(d) { return d.field == "topic_facet" ? "1" : "0" })
          .attr("tabindex", 0)
          .append("div")
          .call(settext)
          .attr("class", function(d) { return d.children ? "label" : "notalabel";} )
          .insert("div")
	  .call(setscreenreader);
    }

});

function position() {
  this.style("left", function(d) { return d.parentlevel ? d.x + 3 + "px" : d.x + "px"; })
      .style("top", function(d) { return d.parentlevel ? d.y + 3 + "px" : d.y + "px"; })
      .style("width", function(d) { return d.parentlevel ? Math.max(0, d.dx - 4) + "px" : Math.max(0, d.dx - 1) + "px"; })
      .style("height", function(d) { return d.parentlevel ? Math.max(0, d.dy - 4) + "px" : Math.max(0, d.dy -1) + "px"; });
}

function settext() {
    this.text(function(d) {
        if (!d.children && d.field == "callnumber-first") {return "";}
        if (d.field == "callnumber-first") {return d.name + " (" + d.count + ")"; }
        if (d.field == "topic_facet" && d.name == "<?=$this->transEsc('More Topics')?>") {var topics = "<?=$this->translate('more_topics')?>"; return topics.replace("%%count%%", d.count); }
        if (d.field == "topic_facet") {return d.name + " (" + d.count + ")"; }
    });
}

function setscreenreader() {
    this.attr("class", "offscreen")
 	.text(function(d) {
	    if (d.field == "topic_facet") {
	        return "<?=$this->transEsc('From')?> " + d.parentlevel;
            } else {
                return "";
	    }
	});
}

function settitle() {
  this.attr("title", function(d) {
    if (d.field == "callnumber-first") {return d.name + " (" + d.count + " <?=$this->transEsc('items')?>)"; }
    if (d.field == "topic_facet" && d.name == "<?=$this->transEsc('More Topics')?>") {var topics = "<?=$this->translate('more_topics')?>"; return topics.replace("%%count%%", d.count); }
    if (d.field == "topic_facet") {var on_topic = "<?=$this->translate('on_topic')?>"; return d.name + " (" + on_topic.replace("%%count%%", d.count) + ")"; }
  });
}

</script>

<? endif; ?>
