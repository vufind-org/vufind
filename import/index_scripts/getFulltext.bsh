/**
 * Custom full text retrieval script.
 *
 * This can be used to override built-in SolrMarc custom functions.  If you change
 * this script, you will need to activate it in import/marc_local.properties before
 * it will be applied during indexing.
 */
import org.marc4j.marc.Record;
import org.marc4j.marc.DataField;
import java.util.regex.Pattern;
import java.io.*;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

// define the base level indexer so that its methods can be called from the script.
// note that the SolrIndexer code will set this value before the script methods are called.
org.solrmarc.index.SolrIndexer indexer = null;

/**
 * Load configurations for the full text parser.  Return an array containing the
 * parser type in the first element and the parser configuration in the second
 * element.
 *
 * @return String[]
 */
public String[] getFulltextParserSettings()
{
    String parserType = indexer.getConfigSetting(
        "fulltext.ini", "General", "parser"
    );
    if (null != parserType) {
        parserType = parserType.toLowerCase();
    }

    // Is Aperture active?
    String aperturePath = indexer.getConfigSetting(
        "fulltext.ini", "Aperture", "webcrawler"
    );
    if ((null == parserType && null != aperturePath)
        || (null != parserType && parserType.equals("aperture"))
    ) {
        String[] array = { "aperture", aperturePath };
        return array;
    }

    // Is Tika active?
    String tikaPath = indexer.getConfigSetting(
        "fulltext.ini", "Tika", "path"
    );
    if ((null == parserType && null != tikaPath)
        || (null != parserType && parserType.equals("tika"))
    ) {
        String[] array = { "tika", tikaPath };
        return array;
    }

    // No recognized parser found:
    String[] array = { "none", null };
    return array;
}

/**
 * Extract full-text from the documents referenced in the tags
 *
 * @param Record record
 * @param String field spec to search for URLs
 * @param String only harvest files matching this extension (null for all)
 * @return String The full-text
 */
public String getFulltext(Record record, String fieldSpec, String extension) {
    String result = "";

    // Get the web crawler settings (and return no text if it is unavailable)
    String[] parserSettings = getFulltextParserSettings();
    if (parserSettings[0].equals("none")) {
        return null;
    }

    // Loop through the specified MARC fields:
    Set fields = indexer.getFieldList(record, fieldSpec);
    Iterator fieldsIter = fields.iterator();
    if (fields != null) {
        while(fieldsIter.hasNext()) {
            // Get the current string to work on (and sanitize spaces):
            String current = fieldsIter.next().replaceAll(" ", "%20");
            // Filter by file extension
            if (extension == null || current.endsWith(extension)) {
                // Load the parser output for each tag into a string
                result = result + harvestWithParser(current, parserSettings);
            }
        }
    }
    // return string to SolrMarc
    return result;
}

/**
 * Extract full-text from the documents referenced in the tags
 *
 * @param Record record
 * @param String field spec to search for URLs
 * @return String The full-text
 */
public String getFulltext(Record record, String fieldSpec) {
    return getFulltext(record, fieldSpec, null);
}

/**
 * Extract full-text from the documents referenced in the tags
 *
 * @param Record record
 * @return String The full-text
 */
public String getFulltext(Record record) {
    return getFulltext(record, "856u", null);
}

/**
 * Clean up XML data generated by Aperture
 *
 * @param File The file to clean
 * @return File A fixed version of the file
 */
public File sanitizeApertureOutput(File f)
{
    //clean up the aperture xml output
    File tempFile = File.createTempFile("buffer", ".tmp");
    FileOutputStream fw = new FileOutputStream(tempFile);
    Writer writer = new OutputStreamWriter(fw, "UTF8");

    //delete this control character from the File and save
    Reader fr = new FileReader(f);
    BufferedReader br = new BufferedReader(fr);
    while (br.ready()) {
        writer.write(sanitizeFullText(br.readLine()));
    }
    writer.close();
    br.close();
    fr.close();

    return tempFile;
}

/**
 * Clean up bad characters in the full text.
 *
 * @param String Text to clean
 * @return String Cleaned text
 */
public String sanitizeFullText(text)
{
    String badChars = "[^\\u0009\\u000A\\u000D\\u0020-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]+";
    return text.replaceAll(badChars, " ");
}

/**
 * Harvest the contents of a document file (PDF, Word, etc.) using Aperture.
 * This method will only work if Aperture is properly configured in the
 * fulltext.ini file.  Without proper configuration, this will simply return an
 * empty string.
 *
 * @param String The url extracted from the MARC tag.
 * @param String The path to Aperture
 * @return String The full-text
 */
public String harvestWithAperture(url, aperturePath) {
    String plainText = "";
    // Create temp file.
    File f = File.createTempFile("apt", ".txt");

    // Delete temp file when program exits.
    f.deleteOnExit();

    // Construct the command to call Aperture
    String cmd = aperturePath + " -o " + f.getAbsolutePath().toString()  + " -x " + url;

    // Call Aperture
    //System.out.println("Loading fulltext from " + url + ". Please wait ...");
    Process p = Runtime.getRuntime().exec(cmd);
    BufferedReader stdInput = new BufferedReader(new
        InputStreamReader(p.getInputStream()));
    while ((s = stdInput.readLine()) != null) {
        //System.out.println(s);
    }
    // Wait for Aperture to finish
    p.waitFor();

    // Parse Aperture XML output
    try {
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        File tempFile = sanitizeApertureOutput(f);
        Document xmlDoc = db.parse(tempFile);
        NodeList nl = xmlDoc.getElementsByTagName("plainTextContent");
        if(nl != null && nl.getLength() > 0) {
            Node node = nl.item(0);
            if (node.getNodeType() == Node.ELEMENT_NODE) {
                plainText = plainText + node.getTextContent();
            }
        }

        // we'll hold onto the temp file if it failed to parse for debugging;
        // only set it up to be deleted if we've made it this far successfully.
        tempFile.deleteOnExit();
    } catch (Exception e) {
        indexer.getLogger().error("Error encountered parsing XML Document: " + e);
    }

    return plainText;
}

/**
 * Harvest the contents of a document file (PDF, Word, etc.) using Tika.
 * This method will only work if Tika is properly configured in the fulltext.ini
 * file.  Without proper configuration, this will simply return an empty string.
 *
 * @param String The url extracted from the MARC tag.
 * @param String The path to Tika
 * @return String The full-text
 */
public String harvestWithTika(url, scraperPath) {
    String plainText = "";

    // Construct the command
    String cmd = "java -jar " + scraperPath + " -t -eUTF8 " + url;

    // Call our scraper
    //System.out.println("Loading fulltext from " + url + ". Please wait ...");
    Process p = Runtime.getRuntime().exec(cmd);
    BufferedReader stdInput = new BufferedReader(new
        InputStreamReader(p.getInputStream(), "UTF8"));

    // We'll build the string from the command output
    StringBuilder stringBuilder= new StringBuilder();
    while ((s = stdInput.readLine()) != null) {
        stringBuilder.append(s);
    }

    return sanitizeFullText(stringBuilder.toString());
}

/**
 * Harvest the contents of a document file (PDF, Word, etc.) using the active parser.
 *
 * @param String The url extracted from the MARC tag.
 * @param String[] Configuration settings from getFulltextParserSettings.
 * @return String The full-text
 */
public String harvestWithParser(url, settings) {
    if (settings[0].equals("aperture")) {
        return harvestWithAperture(url, settings[1]);
    } else if (settings[0].equals("tika")) {
        return harvestWithTika(url, settings[1]);
    }
    return null;
}
