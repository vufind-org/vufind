import org.marc4j.marc.Record;
import org.marc4j.marc.DataField;
import org.solrmarc.index.UpdateDateTracker;
import org.ini4j.Ini;
import java.util.Arrays;

// define the base level indexer so that its methods can be called from the script.
// note that the SolrIndexer code will set this value before the script methods are called.
org.solrmarc.index.SolrIndexer indexer = null;

/**
 * Check if a particular Datafield meets the specified relator requirements.
 * @param authorField      Field to analyze
 * @param noRelatorAllowed Array of tag names which are allowed to be used with
 * no declared relator.
 * @param relatorConfig    The setting in author-classification.ini which
 * defines which relator terms are acceptable (or a colon-delimited list)
 * @return Boolean
 */
public Boolean authorHasAppropriateRelator(DataField authorField,
    String[] noRelatorAllowed, String relatorConfig
) {
    return getValidRelators(authorField, noRelatorAllowed, relatorConfig).size() > 0;
}

/**
 * Extract all valid relator terms from a list of subfields using a whitelist.
 * @param subfields      List of subfields to check
 * @param permittedRoles Whitelist to check against
 * @return Set of valid relator terms
 */
public Set getValidRelatorsFromSubfields(List subfields, List permittedRoles)
{
    Set relators = new LinkedHashSet();
    for (int j = 0; j < subfields.size(); j++) {
        String current = normalizeRelatorString(subfields.get(j).getData());
        if (permittedRoles.contains(current)) {
            relators.add(current);
        }
    }
    return relators;
}

/**
 * Extract all values that meet the specified relator requirements.
 * @param authorField      Field to analyze
 * @param noRelatorAllowed Array of tag names which are allowed to be used with
 * no declared relator.
 * @param relatorConfig    The setting in author-classification.ini which
 * defines which relator terms are acceptable (or a colon-delimited list)
 * @return Set
 */
public Set getValidRelators(DataField authorField,
    String[] noRelatorAllowed, String relatorConfig
) {
    // get tag number from Field
    String tag = authorField.getTag();
    List subfieldE = authorField.getSubfields('e');
    List subfield4 = authorField.getSubfields('4');

    Set relators = new LinkedHashSet();

    // if no relator is found, check to see if the current tag is in the "no
    // relator allowed" list.
    if (subfieldE.size() == 0 && subfield4.size() == 0) {
        if (Arrays.asList(noRelatorAllowed).contains(tag)) {
            relators.add("");
        }
    } else {
        // If we got this far, we need to figure out what type of relation they have
        List permittedRoles = normalizeRelatorStringList(Arrays.asList(loadRelatorConfig(relatorConfig)));
        relators.addAll(getValidRelatorsFromSubfields(subfieldE, permittedRoles));
        relators.addAll(getValidRelatorsFromSubfields(subfield4, permittedRoles));
    }
    return relators;
}

/**
 * Parse a SolrMarc fieldspec into a map of tag name to set of subfield strings
 * (note that we need to map to a set rather than a single string, because the
 * same tag may repeat with different subfields to extract different sections
 * of the same field into distinct values).
 *
 * @param tagList The field specification to parse
 * @return HashMap
 */
public HashMap getParsedTagList(String tagList)
{
    String[] tags = tagList.split(":");//convert string input to array
    HashMap tagMap = new HashMap();
    //cut tags array up into key/value pairs in hash map
    Set currentSet;
    for(int i = 0; i < tags.length; i++){
        String tag = tags[i].substring(0, 3);
        if (!tagMap.containsKey(tag)) {
            currentSet = new LinkedHashSet();
            tagMap.put(tag, currentSet);
        } else {
            currentSet = tagMap.get(tag);
        }
        currentSet.add(tags[i].substring(3));
    }
    return tagMap;
}

/**
 * Filter values retrieved using tagList to include only those whose relator
 * values are acceptable. Used for separating different types of authors.
 *
 * @param record               The record (fed in automatically)
 * @param tagList              The field specification to read
 * @param acceptWithoutRelator Colon-delimited list of tags whose values should
 * be accepted even if no relator subfield is defined
 * @param relatorConfig        The setting in author-classification.ini which
 * defines which relator terms are acceptable (or a colon-delimited list)
 * @param firstOnly            Return first result only?
 * @return List result
 */
public List getAuthorsFilteredByRelator(Record record, String tagList,
    String acceptWithoutRelator, String relatorConfig, Boolean firstOnly
) {
    List result = new LinkedList();
    String[] noRelatorAllowed = acceptWithoutRelator.split(":");
    HashMap parsedTagList = getParsedTagList(tagList);
    List fields = indexer.getFieldSetMatchingTagList(record, tagList);
    Iterator fieldsIter = fields.iterator();
    if (fields != null){
        DataField authorField;
        while (fieldsIter.hasNext()){
            authorField = (DataField) fieldsIter.next();
            // add all author types to the result set; if we have multiple relators, repeat the authors
            for (String iterator: getValidRelators(authorField, noRelatorAllowed, relatorConfig)) {
                for (String subfields : parsedTagList.get(authorField.getTag())) {
                    String current = indexer.getDataFromVariableField(authorField, "["+subfields+"]", " ", false);
                    // TODO: we may eventually be able to use this line instead,
                    // but right now it's not handling separation between the
                    // subfields correctly, so it's commented out until that is
                    // fixed.
                    //String current = authorField.getSubfieldsAsString(subfields);
                    if (null != current) {
                        result.add(current);
                        if (firstOnly) {
                            return result;
                        }
                    }
                }
            }
        }
    }
    return result;
}

/**
 * Filter values retrieved using tagList to include only those whose relator
 * values are acceptable. Used for separating different types of authors.
 *
 * @param record               The record (fed in automatically)
 * @param tagList              The field specification to read
 * @param acceptWithoutRelator Colon-delimited list of tags whose values should
 * be accepted even if no relator subfield is defined
 * @param relatorConfig        The setting in author-classification.ini which
 * defines which relator terms are acceptable (or a colon-delimited list)
 * @return List result
 */
public List getAuthorsFilteredByRelator(Record record, String tagList,
    String acceptWithoutRelator, String relatorConfig
) {
    // default firstOnly to false!
    return getAuthorsFilteredByRelator(
        record, tagList, acceptWithoutRelator, relatorConfig, false
    );
}

/**
 * Filter values retrieved using tagList to include only those whose relator
 * values are acceptable. Used for separating different types of authors.
 *
 * @param record               The record (fed in automatically)
 * @param tagList              The field specification to read
 * @param acceptWithoutRelator Colon-delimited list of tags whose values should
 * be accepted even if no relator subfield is defined
 * @param relatorConfig        The setting in author-classification.ini which
 * defines which relator terms are acceptable (or a colon-delimited list)
 * @return String
 */
public String getFirstAuthorFilteredByRelator(Record record, String tagList,
    String acceptWithoutRelator, String relatorConfig
) {
    List result = getAuthorsFilteredByRelator(
        record, tagList, acceptWithoutRelator, relatorConfig, true
    );
    for (String s : result) {
        return s;
    }
    return null;
}

/**
 * Filter values retrieved using tagList to include only those whose relator
 * values are acceptable. Used for saving relators of authors separated by different
 * types.
 *
 * @param record               The record (fed in automatically)
 * @param tagList              The field specification to read
 * @param acceptWithoutRelator Colon-delimited list of tags whose values should
 * be accepted even if no relator subfield is defined
 * @param relatorConfig        The setting in author-classification.ini which
 * defines which relator terms are acceptable (or a colon-delimited list)
 * @param firstOnly            Return first result only?
 * @return List result
 */
public List getRelatorsFilteredByRelator(Record record, String tagList,
    String acceptWithoutRelator, String relatorConfig, Boolean firstOnly,
    String defaultRelator
) {
    List result = new LinkedList();
    String[] noRelatorAllowed = acceptWithoutRelator.split(":");
    HashMap parsedTagList = getParsedTagList(tagList);
    List fields = indexer.getFieldSetMatchingTagList(record, tagList);
    Iterator fieldsIter = fields.iterator();
    if (fields != null){
        DataField authorField;
        while (fieldsIter.hasNext()){
            authorField = (DataField) fieldsIter.next();
            //add all author types to the result set
            result.addAll(getValidRelators(authorField, noRelatorAllowed, relatorConfig));
        }
    }
    return result;
}

/**
 * Filter values retrieved using tagList to include only those whose relator
 * values are acceptable. Used for saving relators of authors separated by different
 * types.
 *
 * @param record               The record (fed in automatically)
 * @param tagList              The field specification to read
 * @param acceptWithoutRelator Colon-delimited list of tags whose values should
 * be accepted even if no relator subfield is defined
 * @param relatorConfig        The setting in author-classification.ini which
 * defines which relator terms are acceptable (or a colon-delimited list)
 * @return List result
 */
public List getRelatorsFilteredByRelator(Record record, String tagList,
    String acceptWithoutRelator, String relatorConfig
) {
    // default firstOnly to false!
    return getRelatorsFilteredByRelator(
        record, tagList, acceptWithoutRelator, relatorConfig, false, ""
    );
}

/**
 * This method fetches relator definitions from ini file and casts them to an
 * array. If a colon-delimited string is passed in, this will be directly parsed
 * instead of resorting to .ini loading.
 *
 * @param setting Setting to load from .ini or colon-delimited list.
 * @return String[]
 */
public String[] loadRelatorConfig(String setting) {
    StringBuilder relators = new StringBuilder();

    // check for pipe-delimited string
    String[] relatorSettings = setting.split("\\|");
    for (String relatorSetting: relatorSettings) {
        // check for colon-delimited string
        String[] relatorArray = relatorSetting.split(":");
        if (relatorArray.length > 1) {
            for (int i = 0; i < relatorArray.length; i++) {
                relators.append(relatorArray[i]).append(",");
            }
        } else {
            relators.append(indexer.getConfigSetting(
                "author-classification.ini", "AuthorRoles", relatorSetting
            )).append(",");
        }
    }

    return relators.toString().split(",");
}

/**
 * Normalizes the strings in a list.
 *
 * @param stringList List of strings to be normalized
 * @return stringList Normalized List of strings 
 */
public List normalizeRelatorStringList(List stringList)
{
    for (int j = 0; j < stringList.size(); j++) {
        stringList.set(
            j,
            normalizeRelatorString(stringList.get(j))
        );
    }
    return stringList;
}

/**
 * Normalizes a string
 *
 * @param string String to be normalized
 * @return string
 */
public String normalizeRelatorString(String string)
{
    return string
        .trim()
        .toLowerCase()
        .replaceAll("\\p{Punct}+", "");    //POSIX character class Punctuation: One of !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
}

/**
 * Filter values retrieved using tagList to include only those whose relator
 * values are acceptable. Used for separating different types of authors.
 *
 * @param record               The record (fed in automatically)
 * @param tagList              The field specification to read
 * @param acceptWithoutRelator Colon-delimited list of tags whose values should
 * be accepted even if no relator subfield is defined
 * @param relatorConfig        The setting in author-classification.ini which
 * defines which relator terms are acceptable (or a colon-delimited list)
 * @param firstOnly            Return first result only?
 * @return List result
 */
public List getAuthorInitialsFilteredByRelator(Record record, String tagList,
    String acceptWithoutRelator, String relatorConfig
) {
    List authors = getAuthorsFilteredByRelator(record, tagList, acceptWithoutRelator, relatorConfig);
    List result = new LinkedList();
    for (String author : authors) {
        result.add(this.processInitials(author));
    }
    return result;
}

/**
 * Takes a name and cuts it into initials
 * @param authorName e.g. Yeats, William Butler
 * @return initials e.g. w b y wb
 */
public String processInitials(String authorName) {
    Boolean isPersonalName = false;
    // we guess that if there is a comma before the end - this is a personal name
    if ((authorName.indexOf(',') > 0) 
        && (authorName.indexOf(',') < authorName.length()-1)) {
        isPersonalName = true;
    }
    // get rid of non-alphabet chars but keep hyphens and accents 
    authorName = authorName.replaceAll("[^\\p{L} -]", "").toLowerCase();
    String[] names = authorName.split(" "); //split into tokens on spaces
    // if this is a personal name we'll reorganise to put lastname at the end
    String result = "";
    if (isPersonalName) {
        String lastName = names[0]; 
        for (int i = 0; i < names.length-1; i++) {
            names[i] = names[i+1];
        }
        names[names.length-1] = lastName;
    }
    // put all the initials together in a space separated string
    for (String name : names) {
        if (name.length() > 0) {
            String initial = name.substring(0,1);
            // if there is a hyphenated name, use both initials
            int pos = name.indexOf('-');
            if (pos > 0 && pos < name.length() - 1) {
                String extra = name.substring(pos+1, pos+2);
                initial = initial + " " + extra;
            }
            result += " " + initial; 
        }
    }
    // grab all initials and stick them together
    String smushAll = result.replaceAll(" ", "");
    // if it's a long personal name, get all but the last initials as well
    // e.g. wb for william butler yeats
    if (names.length > 2 && isPersonalName) {
        String smushPers = result.substring(0,result.length()-1).replaceAll(" ","");
        result = result + " " + smushPers;
    }
    // now we have initials separate and together
    if (!result.trim().equals(smushAll)) {
        result += " " + smushAll; 
    }
    result = result.trim();
    return result;
}